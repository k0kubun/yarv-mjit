/* -*- mode:c; style:ruby; coding: utf-8; indent-tabs-mode: nil -*- */

% # Copyright (c) 2018 Takashi Kokubun.  All rights reserved.
% #
% # This file is a part of  the programming language Ruby.  Permission is hereby
% # granted, to either  redistribute and/or modify this file,  provided that the
% # conditions mentioned  in the  file COPYING  are met.   Consult the  file for
% # details.
<%= render 'copyright' %>
%
% # This is an ERB template that generates Ruby code that generates C code that
% # generates JIT-ed C code.
<%= render 'notice', locals: {
    this_file: 'is the main part of compile_insn() in mjit_compile.c',
    edit: __FILE__,
} -%>
%
% unsupported_insns = [
%   'getblockparamproxy',  # TODO: support this
%   'defineclass',         # low priority
%   'opt_call_c_function', # low priority
% ]
%
% to_cstr = lambda do |line|
%   normalized = line.gsub(/\t/, ' ' * 8)
%   indented = normalized.sub(/\A/, '    ')
%   rstring2cstr(indented.rstrip).sub(/"\z/, '\\n"')
% end
%
% # Available variables and macros in JIT-ed function:
% #   ec: the first argument of _mjitXXX
% #   reg_cfp: the second argument of _mjitXXX
% #   GET_CFP(): refers to `reg_cfp`
% #   GET_EP(): refers to `reg_cfp->ep`
% #   GET_SELF(): refers to `reg_cfp->self`
% #   GET_LEP(): refers to `VM_EP_LEP(reg_cfp->ep)`

/* Move program counter to meet catch table condition and for JIT execution cancellation. */
fprintf(f, "  reg_cfp->pc = (VALUE *)0x%"PRIxVALUE";\n", (VALUE)(body->iseq_encoded + next_pos));
/* Move stack pointer to let stack values be used by VM when exception is raised */
fprintf(f, "  reg_cfp->sp = reg_cfp->bp + %d;\n", b->stack_size + 1); /* Note: This line makes JIT slow */

switch (insn) {
% (RubyVM::BareInstructions.to_a + RubyVM::OperandsUnifications.to_a).each do |insn|
%   next if unsupported_insns.include?(insn.name)
  case BIN(<%= insn.name %>):
%   case insn.name
%   when 'concatstrings'
    fprintf(f, "  stack[%d] = rb_str_concat_literals(0x%"PRIxVALUE", stack + %d);\n",
            b->stack_size - (unsigned int)operands[0], operands[0], b->stack_size - (unsigned int)operands[0]);
    b->stack_size += 1 - (unsigned int)operands[0];
%   when 'toregexp'
    fprintf(f, "  {\n");
    fprintf(f, "    VALUE rb_reg_new_ary(VALUE ary, int options);\n");
    fprintf(f, "    VALUE rb_ary_tmp_new_from_values(VALUE, long, const VALUE *);\n");
    fprintf(f, "    const VALUE ary = rb_ary_tmp_new_from_values(0, 0x%"PRIxVALUE", stack + %d);\n", operands[1], b->stack_size - (unsigned int)operands[1]);
    fprintf(f, "    stack[%d] = rb_reg_new_ary(ary, (int)0x%"PRIxVALUE");\n", b->stack_size - (unsigned int)operands[1], operands[0]);
    fprintf(f, "    rb_ary_clear(ary);\n");
    fprintf(f, "  }\n");
    b->stack_size += 1 - (unsigned int)operands[1];
%   when 'newarray'
    fprintf(f, "  stack[%d] = rb_ary_new4(0x%"PRIxVALUE", stack + %d);\n",
            b->stack_size - (unsigned int)operands[0], operands[0], b->stack_size - (unsigned int)operands[0]);
    b->stack_size += 1 - (unsigned int)operands[0];
%   when 'expandarray'
    {
        unsigned int space_size;
        space_size = (unsigned int)operands[0] + (unsigned int)((int)operands[1] & 0x01);

        fprintf(f, "  reg_cfp->sp = reg_cfp->bp + %d;\n", b->stack_size); /* For `VALUE ary` argument. TODO: reg_cfp->sp should be set once */
        fprintf(f, "  vm_expandarray(reg_cfp, stack[%d], 0x%"PRIxVALUE", (int)0x%"PRIxVALUE");\n", --b->stack_size, operands[0], operands[1]);
        b->stack_size += space_size;
    }
%   when 'newhash'
    fprintf(f, "  {\n");
    fprintf(f, "    VALUE val;\n");
    fprintf(f, "    RUBY_DTRACE_CREATE_HOOK(HASH, 0x%"PRIxVALUE");\n", operands[0]);
    fprintf(f, "    val = rb_hash_new_with_size(0x%"PRIxVALUE" / 2);\n", operands[0]);
    if (operands[0]) {
        fprintf(f, "    rb_hash_bulk_insert(0x%"PRIxVALUE", stack + %d, val);\n", operands[0], b->stack_size - (unsigned int)operands[0]);
    }
    fprintf(f, "    stack[%d] = val;\n", b->stack_size - (unsigned int)operands[0]);
    fprintf(f, "  }\n");
    b->stack_size += 1 - (unsigned int)operands[0];
%   when 'dupn'
    fprintf(f, "  MEMCPY(stack + %d, stack + %d, VALUE, 0x%"PRIxVALUE");\n",
            b->stack_size, b->stack_size - (unsigned int)operands[0], operands[0]);
    b->stack_size += (unsigned int)operands[0];
%   when 'reverse'
    {
        unsigned int n, i, base;
        n = (unsigned int)operands[0];
        base = b->stack_size - n;

        fprintf(f, "  {\n");
        fprintf(f, "    VALUE v0;\n");
        fprintf(f, "    VALUE v1;\n");
        for (i = 0; i < n/2; i++) {
            fprintf(f, "    v0 = stack[%d];\n", base + i);
            fprintf(f, "    v1 = stack[%d];\n", base + n - i - 1);
            fprintf(f, "    stack[%d] = v1;\n", base + i);
            fprintf(f, "    stack[%d] = v0;\n", base + n - i - 1);
        }
        fprintf(f, "  }\n");
    }
%   when 'reput'
    fprintf(f, "  stack[%d] = stack[%d];\n", b->stack_size-1, b->stack_size-1);
%   when 'topn'
    fprintf(f, "  stack[%d] = stack[%d];\n", b->stack_size, b->stack_size - 1 - (unsigned int)operands[0]);
    b->stack_size++;
%   when 'setn'
    fprintf(f, "  stack[%d] = stack[%d];\n", b->stack_size - 1 - (unsigned int)operands[0], b->stack_size-1);
%   when 'adjuststack'
    b->stack_size -= (unsigned int)operands[0];
%   when 'send'
    b->stack_size += compile_send(f, insn, operands, b->stack_size, TRUE);
    fprint_trace_cancel(f, b->stack_size);
%   when 'opt_newarray_max'
    fprintf(f, "  stack[%d] = vm_opt_newarray_max(0x%"PRIxVALUE", stack + %d);\n",
            b->stack_size - (unsigned int)operands[0], operands[0], b->stack_size - (unsigned int)operands[0]);
    b->stack_size += 1 - (unsigned int)operands[0];
%   when 'opt_newarray_min'
    fprintf(f, "  stack[%d] = vm_opt_newarray_min(0x%"PRIxVALUE", stack + %d);\n",
            b->stack_size - (unsigned int)operands[0], operands[0], b->stack_size - (unsigned int)operands[0]);
    b->stack_size += 1 - (unsigned int)operands[0];
%   when 'opt_send_without_block'
    b->stack_size += compile_send(f, insn, operands, b->stack_size, FALSE);
    fprint_trace_cancel(f, b->stack_size);
%   when 'invokesuper'
    {
        CALL_INFO ci = (CALL_INFO)operands[0];
        unsigned int push_count = ci->orig_argc + ((ci->flag & VM_CALL_ARGS_BLOCKARG) ? 1 : 0);

        fprintf(f, "  {\n");
        fprintf(f, "    struct rb_calling_info calling;\n");
        fprintf(f, "    calling.argc = %d;\n", ci->orig_argc);
        fprintf(f, "    vm_caller_setup_arg_block(ec, reg_cfp, &calling, 0x%"PRIxVALUE", 0x%"PRIxVALUE", TRUE);\n", operands[0], operands[2]);
        fprintf(f, "    calling.recv = reg_cfp->self;\n");
        fprintf(f, "    vm_search_super_method(ec, reg_cfp, &calling, 0x%"PRIxVALUE", 0x%"PRIxVALUE");\n", operands[0], operands[1]);
        fprintf(f, "    {\n");
        fprintf(f, "      VALUE v = (*((CALL_CACHE)0x%"PRIxVALUE")->call)(ec, reg_cfp, &calling, 0x%"PRIxVALUE", 0x%"PRIxVALUE");\n", operands[1], operands[0], operands[1]);
        fprintf(f, "      if (v == Qundef && (v = mjit_exec(ec)) == Qundef) {\n"); /* TODO: we need some check to call `mjit_exec` directly (skipping setjmp), but not done yet */
        fprintf(f, "        VM_ENV_FLAGS_SET(ec->cfp->ep, VM_FRAME_FLAG_FINISH);\n"); /* This is vm_call0_body's code after vm_call_iseq_setup */
        fprintf(f, "        stack[%d] = vm_exec(ec);\n", b->stack_size - push_count - 1);
        fprintf(f, "      } else {\n");
        fprintf(f, "        stack[%d] = v;\n", b->stack_size - push_count - 1);
        fprintf(f, "      }\n");
        fprintf(f, "    }\n");
        fprintf(f, "  }\n");
        b->stack_size -= push_count;
        fprint_trace_cancel(f, b->stack_size);
    }
%   when 'invokeblock'
    {
        CALL_INFO ci = (CALL_INFO)operands[0];
        fprintf(f, "  {\n");
        fprintf(f, "    struct rb_calling_info calling;\n");
        fprintf(f, "    VALUE block_handler;\n");

        fprintf(f, "    calling.argc = %d;\n", ci->orig_argc);
        fprintf(f, "    calling.block_handler = VM_BLOCK_HANDLER_NONE;\n");
        fprintf(f, "    calling.recv = Qundef; /* should not be used */\n");

        fprintf(f, "    block_handler = VM_CF_BLOCK_HANDLER(reg_cfp);\n");
        fprintf(f, "    if (block_handler == VM_BLOCK_HANDLER_NONE) {\n");
        fprintf(f, "      rb_vm_localjump_error(\"no block given (yield)\", Qnil, 0);\n");
        fprintf(f, "    }\n");

        fprintf(f, "    {\n");
        fprintf(f, "      VALUE v = vm_invoke_block(ec, reg_cfp, &calling, 0x%"PRIxVALUE", block_handler);\n", operands[0]);
        fprintf(f, "      if (v == Qundef && (v = mjit_exec(ec)) == Qundef) {\n");
        fprintf(f, "        VM_ENV_FLAGS_SET(ec->cfp->ep, VM_FRAME_FLAG_FINISH);\n");
        fprintf(f, "        stack[%d] = vm_exec(ec);\n", b->stack_size - ci->orig_argc);
        fprintf(f, "      } else {\n");
        fprintf(f, "        stack[%d] = v;\n", b->stack_size - ci->orig_argc);
        fprintf(f, "      }\n");
        fprintf(f, "    }\n");
        fprintf(f, "  }\n");
        b->stack_size += 1 - ci->orig_argc;
        fprint_trace_cancel(f, b->stack_size);
    }
%   when 'leave'
    /* NOTE: We don't use YARV's stack on JIT. So vm_stack_consistency_error isn't run
       during execution and we check stack_size here instead. */
    if (b->stack_size != 1) {
        if (mjit_opts.warnings || mjit_opts.verbose)
            fprintf(stderr, "MJIT warning: Unexpected JIT stack_size on leave: %d\n", b->stack_size);
        status->success = FALSE;
    }

    fprintf(f, "  reg_cfp->sp = reg_cfp->bp + 1;\n"); /* pop result to resolve consistency error */
    fprintf(f, "  RUBY_VM_CHECK_INTS(ec);\n");
    /* TODO: is there a case that vm_pop_frame returns 0? */
    fprintf(f, "  vm_pop_frame(ec, reg_cfp, reg_cfp->ep);\n");
#if OPT_CALL_THREADED_CODE
    fprintf(f, "  ec->retval = stack[%d];\n", b->stack_size-1);
    fprintf(f, "  return 0;\n");
#else
    fprintf(f, "  return stack[%d];\n", b->stack_size-1);
#endif
    /* stop compilation in this branch. to simulate stack properly,
       remaining insns should be compiled from another branch */
    b->finish_p = TRUE;
%   when 'throw'
    fprintf(f, "  RUBY_VM_CHECK_INTS(ec);\n");
    fprintf(f, "  ec->errinfo = vm_throw(ec, reg_cfp, 0x%"PRIxVALUE", stack[%d]);\n", operands[0], --b->stack_size);
    fprintf(f, "  EC_JUMP_TAG(ec, ec->tag->state);\n");
    b->finish_p = TRUE;
%   when 'jump'
    next_pos = pos + insn_len(insn) + (unsigned int)operands[0];
    fprintf(f, "  RUBY_VM_CHECK_INTS(ec);\n");
    fprintf(f, "  goto label_%d;\n", next_pos);
%   when 'branchif'
    fprintf(f, "  if (RTEST(stack[%d])) {\n", --b->stack_size);
    fprintf(f, "    RUBY_VM_CHECK_INTS(ec);\n");
    fprintf(f, "    goto label_%d;\n", pos + insn_len(insn) + (unsigned int)operands[0]);
    fprintf(f, "  }\n");
    compile_insns(f, body, b->stack_size, pos + insn_len(insn), status);
    next_pos = pos + insn_len(insn) + (unsigned int)operands[0];
%   when 'branchunless'
    fprintf(f, "  if (!RTEST(stack[%d])) {\n", --b->stack_size);
    fprintf(f, "    RUBY_VM_CHECK_INTS(ec);\n");
    fprintf(f, "    goto label_%d;\n", pos + insn_len(insn) + (unsigned int)operands[0]);
    fprintf(f, "  }\n");
    compile_insns(f, body, b->stack_size, pos + insn_len(insn), status);
    next_pos = pos + insn_len(insn) + (unsigned int)operands[0];
%   when 'branchnil'
    fprintf(f, "  if (NIL_P(stack[%d])) {\n", --b->stack_size);
    fprintf(f, "    RUBY_VM_CHECK_INTS(ec);\n");
    fprintf(f, "    goto label_%d;\n", pos + insn_len(insn) + (unsigned int)operands[0]);
    fprintf(f, "  }\n");
    compile_insns(f, body, b->stack_size, pos + insn_len(insn), status);
    next_pos = pos + insn_len(insn) + (unsigned int)operands[0];
%   when 'branchiftype'
    fprintf(f, "  if (TYPE(stack[%d]) == (int)0x%"PRIxVALUE") {\n", --b->stack_size, operands[0]);
    fprintf(f, "    RUBY_VM_CHECK_INTS(ec);\n");
    fprintf(f, "    goto label_%d;\n", pos + insn_len(insn) + (unsigned int)operands[1]);
    fprintf(f, "  }\n");
    compile_insns(f, body, b->stack_size, pos + insn_len(insn), status);
    next_pos = pos + insn_len(insn) + (unsigned int)operands[1];
%   when 'getinlinecache'
    fprintf(f, "  stack[%d] = vm_ic_hit_p(0x%"PRIxVALUE", reg_cfp->ep);\n", b->stack_size, operands[1]);
    fprintf(f, "  if (stack[%d] != Qnil) {\n", b->stack_size);
    fprintf(f, "    goto label_%d;\n", pos + insn_len(insn) + (unsigned int)operands[0]);
    fprintf(f, "  }\n");
    b->stack_size++;
%   when 'setinlinecache'
    fprintf(f, "  vm_ic_update(0x%"PRIxVALUE", stack[%d], reg_cfp->ep);\n", operands[0], b->stack_size-1);
%   when 'opt_case_dispatch'
    {
        struct case_dispatch_var arg;
        arg.f = f;
        arg.base_pos = pos + insn_len(insn);
        arg.last_value = Qundef;

        fprintf(f, "  switch (vm_case_dispatch(0x%"PRIxVALUE", 0x%"PRIxVALUE", stack[%d])) {\n", operands[0], operands[1], --b->stack_size);
        st_foreach(RHASH_TBL_RAW(operands[0]), compile_case_dispatch_each, (VALUE)&arg);
        fprintf(f, "    case %lu:\n", operands[1]);
        fprintf(f, "      goto label_%lu;\n", arg.base_pos + operands[1]);
        fprintf(f, "  }\n");
    }
%   when 'opt_plus'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2, "vm_opt_plus(recv, obj)");
%   when 'opt_minus'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2, "vm_opt_minus(recv, obj)");
%   when 'opt_mult'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2, "vm_opt_mult(recv, obj)");
%   when 'opt_div'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2, "vm_opt_div(recv, obj)");
%   when 'opt_mod'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2, "vm_opt_mod(recv, obj)");
%   when 'opt_eq'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2,
            "opt_eq_func(recv, obj, 0x%"PRIxVALUE", 0x%"PRIxVALUE")", operands[0], operands[1]);
%   when 'opt_neq'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2,
            "vm_opt_neq(0x%"PRIxVALUE", 0x%"PRIxVALUE", 0x%"PRIxVALUE", 0x%"PRIxVALUE", recv, obj)",
            operands[0], operands[1], operands[2], operands[3]);
%   when 'opt_lt'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2, "vm_opt_lt(recv, obj)");
%   when 'opt_le'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2, "vm_opt_le(recv, obj)");
%   when 'opt_gt'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2, "vm_opt_gt(recv, obj)");
%   when 'opt_ge'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2, "vm_opt_ge(recv, obj)");
%   when 'opt_ltlt'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2, "vm_opt_ltlt(recv, obj)");
%   when 'opt_aref'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2, "vm_opt_aref(recv, obj)");
%   when 'opt_aset'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 3, "vm_opt_aset(recv, obj, obj2)");
%   when 'opt_aset_with'
    b->stack_size += fprint_opt_call_with_key(f, insn, operands[0], operands[1], operands[2], b->stack_size, 3,
            "vm_opt_aset_with(recv, 0x%"PRIxVALUE", obj)", operands[2]);
%   when 'opt_aref_with'
    b->stack_size += fprint_opt_call_with_key(f, insn, operands[0], operands[1], operands[2], b->stack_size, 2,
            "vm_opt_aref_with(recv, 0x%"PRIxVALUE")", operands[2]);
%   when 'opt_length'
    fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 1, "vm_opt_length(recv, BOP_LENGTH)");
%   when 'opt_size'
    fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 1, "vm_opt_length(recv, BOP_SIZE)");
%   when 'opt_empty_p'
    fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 1, "vm_opt_empty_p(recv)");
%   when 'opt_succ'
    fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 1, "vm_opt_succ(recv)");
%   when 'opt_not'
    fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 1,
            "vm_opt_not(0x%"PRIxVALUE", 0x%"PRIxVALUE", recv)", operands[0], operands[1]);
    break;
%   when 'opt_regexpmatch1'
    fprintf(f, "  stack[%d] = vm_opt_regexpmatch1((VALUE)0x%"PRIxVALUE", stack[%d]);\n", b->stack_size-1, operands[0], b->stack_size-1);
%   when 'opt_regexpmatch2'
    b->stack_size += fprint_opt_call(f, insn, operands[0], operands[1], b->stack_size, 2, "vm_opt_regexpmatch2(recv, obj)");
%   else
    fprintf(f, "{\n");
%
%     # Declare variables for operands, popped values and return values
%     insn.declarations.each do |decl|
    fprintf(f, "    <%= decl %>;\n");
%     end

%     # Set const expressions for `RubyVM::OperandsUnifications` insn
%     insn.preamble.each do |amble|
    fprintf(f, "<%= amble.expr %>\n");
%     end
%
%     # Initialize operands
%     insn.opes.each_with_index do |ope, i|
    fprintf(f, "    <%= ope.fetch(:name) %> = (<%= ope.fetch(:type) %>)0x%"PRIxVALUE";\n", operands[<%= i %>]);
%     end
%
%     # Initialize popped values
%     insn.pops.reverse_each.with_index.reverse_each do |pop, i|
    fprintf(f, "    <%= pop.fetch(:name) %> = stack[%d];\n", b->stack_size - <%= i + 1 %>);
%     end
%
%     # Print insn body in insns.def
%     insn.expr.expr.each_line do |line|
    fprintf(f, <%= to_cstr.call(line) %>);
%     end
%
%     # Set return values
%     insn.rets.each_with_index do |ret, i|
    fprintf(f, "    stack[%d] = <%= ret.fetch(:name) %>;\n", b->stack_size - <%= insn.pops.size - i %>);
%     end
    fprintf(f, "}\n");
%
%     # Move JIT compiler's internal stack pointer
%     if insn.has_attribute?('sp_inc')
%       raise 'sp_inc attribute is not supported yet'
%     else
%       sp_inc = insn.rets.size - insn.pops.size
%       if sp_inc != 0
    b->stack_size += <%= sp_inc %>;
%       end
%     end
%
%   end
    break;
% end
%
% # We don't support InstructionsUnifications yet because it's not used for now.
% # We don't support TraceInstructions yet. There is no blocker for it but it's just not implemented.
  default:
    if (mjit_opts.warnings || mjit_opts.verbose >= 3)
        /* passing excessive arguments to suppress warning in insns_info.inc as workaround... */
        fprintf(stderr, "MJIT warning: Failed to compile instruction: %s (%s: %d...)\n",
                insn_name(insn), insn_op_types(insn), insn_len(insn) > 0 ? insn_op_type(insn, 0) : 0);
    status->success = FALSE;
    break;
}

/* if next_pos is already compiled, next instruction won't be compiled in C code and needs `goto`. */
if ((next_pos < body->iseq_size && status->compiled_for_pos[next_pos]) || insn == BIN(jump))
    fprintf(f, "  goto label_%d;\n", next_pos);
