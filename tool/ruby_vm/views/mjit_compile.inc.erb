/* -*- mode:c; style:ruby; coding: utf-8; indent-tabs-mode: nil -*- */

% # Copyright (c) 2018 Takashi Kokubun.  All rights reserved.
% #
% # This file is a part of  the programming language Ruby.  Permission is hereby
% # granted, to either  redistribute and/or modify this file,  provided that the
% # conditions mentioned  in the  file COPYING  are met.   Consult the  file for
% # details.
<%= render 'copyright' %>
%
% # This is an ERB template that generates Ruby code that generates C code that
% # generates JIT-ed C code.
<%= render 'notice', locals: {
    this_file: 'is the main part of compile_insn() in mjit_compile.c',
    edit: __FILE__,
} -%>
%
% unsupported_insns = [
%   'getblockparamproxy',  # TODO: support this
%   'defineclass',         # low priority
%   'opt_call_c_function', # low priority
% ]
%
% # Available variables and macros in JIT-ed function:
% #   ec: the first argument of _mjitXXX
% #   reg_cfp: the second argument of _mjitXXX
% #   GET_CFP(): refers to `reg_cfp`
% #   GET_EP(): refers to `reg_cfp->ep`
% #   GET_SP(): refers to `reg_cfp->sp`
% #   INC_SP(): refers to `reg_cfp->sp`
% #   SET_SV(): refers to `reg_cfp->sp`
% #   PUSH(): refers to `SET_SV()`, `INC_SP()`
% #   GET_SELF(): refers to `reg_cfp->self`
% #   GET_LEP(): refers to `VM_EP_LEP(reg_cfp->ep)`
% #   EXEC_EC_CFP(): refers to `val = vm_exec(ec)` with frame setup
% #   CALL_METHOD(): using `GET_CFP()` and `EXEC_EC_CFP()`
% #   TOPN(): refers to `reg_cfp->sp`, which needs to have correct sp (of course)
% #   STACK_ADDR_FROM_TOP(): refers to `reg_cfp->sp`, same problem here
% #   DISPATCH_ORIGINAL_INSN(): expanded in _mjit_compile_insn.erb

/* Move program counter to meet catch table condition and for JIT execution cancellation. */
fprintf(f, "  reg_cfp->pc = (VALUE *)0x%"PRIxVALUE";\n", (VALUE)(body->iseq_encoded + next_pos));
/* Move stack pointer to let stack values be used by VM when exception is raised */
fprintf(f, "  reg_cfp->sp = reg_cfp->bp + %d;\n", b->stack_size + 1); /* Note: This line makes JIT slow */

switch (insn) {
% (RubyVM::BareInstructions.to_a + RubyVM::OperandsUnifications.to_a).each do |insn|
%   next if unsupported_insns.include?(insn.name)
  case BIN(<%= insn.name %>):
%   case insn.name
%   when 'leave'
    /* NOTE: We don't use YARV's stack on JIT. So vm_stack_consistency_error isn't run
       during execution and we check stack_size here instead. */
    if (b->stack_size != 1) {
        if (mjit_opts.warnings || mjit_opts.verbose)
            fprintf(stderr, "MJIT warning: Unexpected JIT stack_size on leave: %d\n", b->stack_size);
        status->success = FALSE;
    }

    fprintf(f, "  reg_cfp->sp = reg_cfp->bp + 1;\n"); /* pop result to resolve consistency error */
    fprintf(f, "  RUBY_VM_CHECK_INTS(ec);\n");
    /* TODO: is there a case that vm_pop_frame returns 0? */
    fprintf(f, "  vm_pop_frame(ec, reg_cfp, reg_cfp->ep);\n");
#if OPT_CALL_THREADED_CODE
    fprintf(f, "  ec->retval = stack[%d];\n", b->stack_size-1);
    fprintf(f, "  return 0;\n");
#else
    fprintf(f, "  return stack[%d];\n", b->stack_size-1);
#endif
    /* stop compilation in this branch. to simulate stack properly,
       remaining insns should be compiled from another branch */
    b->finish_p = TRUE;
%   when 'throw'
    fprintf(f, "  RUBY_VM_CHECK_INTS(ec);\n");
    fprintf(f, "  ec->errinfo = vm_throw(ec, reg_cfp, 0x%"PRIxVALUE", stack[%d]);\n", operands[0], --b->stack_size);
    fprintf(f, "  EC_JUMP_TAG(ec, ec->tag->state);\n");
    b->finish_p = TRUE;
%   when 'opt_case_dispatch'
    {
        struct case_dispatch_var arg;
        arg.f = f;
        arg.base_pos = pos + insn_len(insn);
        arg.last_value = Qundef;

        fprintf(f, "  switch (vm_case_dispatch(0x%"PRIxVALUE", 0x%"PRIxVALUE", stack[%d])) {\n", operands[0], operands[1], --b->stack_size);
        st_foreach(RHASH_TBL_RAW(operands[0]), compile_case_dispatch_each, (VALUE)&arg);
        fprintf(f, "    case %lu:\n", operands[1]);
        fprintf(f, "      goto label_%lu;\n", arg.base_pos + operands[1]);
        fprintf(f, "  }\n");
    }
%   else
<%= render 'mjit_compile_insn', locals: { insn: insn, dispatched: false } -%>
%   end
    break;
% end
%
% # We don't support InstructionsUnifications yet because it's not used for now.
% # We don't support TraceInstructions yet. There is no blocker for it but it's just not implemented.
  default:
    if (mjit_opts.warnings || mjit_opts.verbose >= 3)
        /* passing excessive arguments to suppress warning in insns_info.inc as workaround... */
        fprintf(stderr, "MJIT warning: Failed to compile instruction: %s (%s: %d...)\n",
                insn_name(insn), insn_op_types(insn), insn_len(insn) > 0 ? insn_op_type(insn, 0) : 0);
    status->success = FALSE;
    break;
}

/* if next_pos is already compiled, next instruction won't be compiled in C code and needs `goto`. */
if ((next_pos < body->iseq_size && status->compiled_for_pos[next_pos]))
    fprintf(f, "  goto label_%d;\n", next_pos);
